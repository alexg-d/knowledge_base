 
Оператор *

* распаковывает итерируемый объект в аргументы вызова
>>> fruits = ['lemon', 'pear', 'watermelon', 'tomato']
>>> print(*fruits)
lemon pear watermelon tomato

** берет словарь с парами ключ-значение и распаковывает его в аргументы функции
>>> date_info = {'year': "2020", 'month': "01", 'day': "01"}
>>> track_info = {'artist': "Beethoven", 'title': 'Symphony No 5'}
>>> filename = "{year}-{month}-{day}-{artist}-{title}.txt".format(
...     **date_info,
...     **track_info,
... )
>>> filename
'2020-01-01-Beethoven-Symphony No 5.txt'

ключи в словарях не должны пересекаться, иначе будет выброшено исключение


Sort() или sorted() может принимать параметр key, тогда сортировка будет выполнена по функции этого ключа

>>> sorted("This is a test string from Andrew".split(), key=str.lower)
['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']
>>> *sorted(set(input().split()) & set(input().split()), key=int)

______

* позволит мне по порядку перечислить все элементы массива, множества, словаря, строки без использования цикла
key=int - позволит мне явно указать по какому типу нужно сортировать итерируемый объект
key может принимать разные функции


Lambda

lambda-выражение позволяет создать анонимную функцию - ф-ю, которая не привязана к имени

В анонимной функции:
- может содержаться только одно выражение
- могут передаваться сколько угодно аргументов

In [3]: sum_arg = lambda a, b: a + b
In [4]: sum_arg(1, 2)
Out[4]: 3

Оператор return не прописывается, т.к. уже включен в анонимную функцию, т.к. АФ должна выполнить выражение, вернуть значение и завершить работу ф-ии.

lambda-выражение можно указывать в ф-ии sort в качестве ключа
In [5]: list_of_tuples = [('IT_VLAN', 320), ('Mngmt_VLAN', 99), ('User_VLAN', 1010), ('DB_VLAN', 11)]
In [6]: sorted(list_of_tuples, key=lambda x: x[1])
Out[6]: [('DB_VLAN', 11), ('Mngmt_VLAN', 99), ('IT_VLAN', 320), ('User_VLAN', 1010)]
// отсортирует объекты по ключу с индексом 1


----------------------


Ф-я zip(a, b) создаёт объект-итератор, из которого при каждом обороте цикла извлекается кортеж, состоящий из двух элементов

itertools.zip_longest - используется, если нужно учесть все значения из самого длинного списка
itertools.zip_longest(a,b,c, fillvalue=0) - чтобы указать свой вариант заполнения (по умолчанию None)

Если требуется получить не итератор, возвращаемый zip(), а список из элементов, то к объекту zip применима функция list, которая преобразует итератор в список.


-----------------------


Получается мы можем заранее определить структуру объекта/коллекции, и при помощи defaultdic организовать соответствующий объект. Для этого нужно в аргументе передать соответствующую функцию.
